<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Heartbleed</title>
  <style>
    body {
      font-family: Cambria, Cochin, Georgia, Times, 'Times New Roman', serif, sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      /* background-color: #f8f8f8; */
    }

    /* header {
      background-color: #333;
      color: #fff;
      padding: 20px;
      text-align: center;
      box-shadow: 20px 20px 20px rgba(0, 0, 0, 0.1);
    } */

    main {
      flex: 1;
      /* padding: 20px; */
      /* margin-left: 220px; Add margin to create space for the sidebar */
      text-align: center;
    }

    aside {
      
      width: 200px;
      background-color: #f0f0f0;
      padding: 20px;
      position: sticky;
      top: 0;
      box-shadow: 2px 0px 4px rgba(0, 0, 0, 0.1);
    }

    nav ul {
      list-style: none;
      padding: 0;
    }

    nav h2 {
      color: #333;
      margin-bottom: 15px;
    }

    nav a {
      text-decoration: none;
      color: #333;
      display: block;
      padding: 8px 0;
    }

    nav li.active {
    font-weight: bold;
    /* Add any other styles you want for the active item */
}

    /* Add styles to make the sidebar float */
    @media (min-width: 768px) {
      aside {
        position: fixed;
        height: 100%;
        overflow-y: auto;
      }

      main {   
        /* -ms-flex: 70%;
        flex: 70%; */
        background-color: white;
        /* padding: 60px; */
        padding-top: 5%;
        padding-left: 25%;
        padding-right: 25%;
        padding-bottom: 15%;
        box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
}
    }

    .image {
  width: 100%;
  padding: 1px;
  background-color: #d4d4d4;
  /* border: none; */
  box-shadow: 20px 20px 20px rgba(0, 0, 0, 0.1);
}


    main h2 {
      text-align: center; /* Center the h2 headers */
      padding-top: 20%;
    }

    main h3 {
      text-align: left;
      padding-left: 2%
    }

    main p {
      text-align: left; /* Left-align the p text */
      padding: 2%;
      line-height: 200%;
    }

    main code {
      padding: 2%
    }

    video {
      display: block;
      margin: auto;
      padding: 10px;
      max-width: calc(100vw - 20px); /* 20px padding on both sides */
      max-height: calc(100vh - 20px); /* 20px padding on top and bottom */
    }

    /* .footer {
      padding: 20px;
      text-align: center;
      background: rgb(255, 255, 255);
} */
  </style>
</head>


<body>

  <!-- <header>
    <h1>Heartbleed</h1>
  </header> -->

  <aside>
    <nav>
      <h1>Heartbleed</h1>
      <ul id="sidebar-nav"></ul>
    </nav>
  </aside>

  <main>
    <h1>Heartbleed</h1>
    <img src="images/HeartbleedOnCode.png" alt="Description of the image" class="image">
    <h2 id="What_Is_Heartbleed">What is Heartbleed?</h2>
    <p>Heartbleed is an out of bounds read, or memory buffer overflow vulnerability in OpenSSL, which allows an attacker to read protected information. Heartbleed would allow anyone on the Internet to read system memory, which includes secret keys, passwords, and other sensitive information.
      It affected 17% of all SSL servers, including companies like Google, Yahoo, Netflix, Facebook and even the FBI.
      Heartbleed is categorized on the NIST database as <a href="https://nvd.nist.gov/vuln/detail/cve-2014-0160">CVE-2014-0160</a> with a base severity score of 7.5/10.

    </p>

    <h2 id="Heartbleed_History">A Short History of Heartbleed</h2>
    <p>The first person to discovery Heartbleed was Neel Mehta, an engineer at Google discovered the vulnerability in March 2014. They later published a website https://heartbleed.com/ to publicize the bug.
      The second discovery came from a Finnish cybersecurity firm Codenomicon just a couple weeks later. The company was working on a product called Safeguard, which would be an encryption and authentication targetted penetration testing tool.</p>

    <h2 id="What_is_OpenSSL">What is OpenSSL?</h2>
    <p>Heartbleed is a bug in the implementation of OpenSSL. OpenSSL implements the SSL/TLS protocol, but it itself is not a protocol.
      Implementing SSL/TLS by scratch is a royal pain, which is why OpenSSL is very widely used. <br>When Heartbleed was first discovered, half a million websites, 
     <a href="https://www.netcraft.com/blog/half-a-million-widely-trusted-websites-vulnerable-to-heartbleed-bug/"> 17% of web SSL servers</a>
      were impacted.
      

      <h2 id="Why_OpenSSL">Why Use OpenSSL Instead of Implementing SSL/TLS by Hand?</h2>
      <p>Now why would OpenSSL be used if the Heartbleed vulnerability is with OpenSSL, and not with SSL/TLS? Wouldn't implementing it by scratch avoid
        having these issues?
        Implementing SSL/TLS by hand sucks. By themselves, they're very complex protocols with a lot going on.
        There's intricate encryption methods and key exchanges that have to be implemented. </p>
        <h3>Encryption Methods</h3>
        
        <p>If these aren't implemented correctly, they pose a large security threat. It's could be like having a properly encoded message, compared
        to an insecurely encoded message where someone just swapped out one letter in the word. Awe3r4oi6u vs. Hillo World, you can probably guess what the latter means.
        </p>
        
        <h3>Key Exchanges</h3>
        <p>
        Key exchanges also have to be done securely. Public keys can be shared, but private keys need to be kept secret. But private keys still need to be verified, so how
        can this be done securely? This is something that needs to be implemented properly, or else the secret private key could be leaked. There are many methods to doing a key 
        exchange, but here you can read about some types of <a href="https://deeprnd.medium.com/cryptographic-key-exchange-5eb9e926edb0">Diffie Hellman Key Exchanges.</a>
        </p>

        <h3>Compliance</h3>
        <p>
          Likewise, there are lots of security standards, and some governmental standards/regulations that need to be abided by. California's privacy policy, GDPR, may need to be followed,
          and if handling patient data, HIPAA needs to be followed. These are considerations that OpenSSL will follow, but may be cumbersome to implement by hand.
        </p>

        <h3>Expertise and Community </h3>
        <p>
          Since OpenSSL is so widely used, it's constantly being looked at and examined by experts, hence how Heartbleed was found by a Google engineer.
          By using OpenSSL, there is the extra assurance that it's been reviewed by lots of people who know what they're doing, and so far haven't found anything.
          Vulnerabilities are coming out every day, so OpenSSL undoubtedly has some that still haven't been discovered, but with a community that uses it, hopefully
          someone will discover an issue before it's used maliciously.
          With this, when a bug is discovered, a patch will be released to fix the issue.
        </p>
    
    <h2 id="How_SSL_Works">How Does SSL Work?</h2>
    <p>
      Okay so how does SSL work? What is it doing, roughly?
      SSL stands for Secure Sockets Layer, and is used for encrypting and authenticating communications over the Internet. 
      SSL was replaced by a newer protocol, called TLS, Transport Layer Security, but is still often referred to as SSL/TLS.
    </p>
    <p>First, some basics.</p>
    <h3>Asymmetric Encryption</h3>
    <p>Asymmetric encryption uses two types of keys, public keys and private keys. Public keys are public, and private keys are kept secret. 
    When the public key is used to encrypt data, the data can only be decrypted with the private key. 
    During the handshake, the client and the server will use this technique to generate random data to create session keys for encryption.
    </p>

    <h3>SSL Certificates</h3>
    <p>
    These are basically a file for a server that contains some information regarding the server, such as its public key, owner identity, digital signature, and more. 
    Certificates can be self signed, but that's just like saying "I pinky promise you I am who I say I am." 
    Whereas you can get a certificate authority to issue you a certificate, and this is more trustworthy, like the DMV saying you are who you say you are.
    </p>

    <h3>Handshake</h3>
    <p>
      !---TLS HANDSHAKE PICTURE---!

      The first step, is the handshake.
      There are different ways to do the handshake depending on the key exchange algorithm being used. RSA will have one, Diffie-Hellman has another. RSA is considered insecure now, and is not advised to be used. So the exact steps will differ, but basically the steps are: <br>
      1. Client sends a hello message to the server, possibly including it's protocol version, cipher suites, and client random. <br>
      2. Server replies, likely with its SSL certificate, it's selected cipher suite (a set of algorithms), and the server random. The server may include a digital signature or other things depending on the algorithm. <br>
      3. The client verifies the server's identity through it's certificate, and/or digital signature. <br>
      4. The client sends over a value to the server. What kind depends on the algorithm. This value is used to create the premaster secret. <br>
      5. The client and the server calculate the premaster secrete separately. <br>
      6. The client and server calculate a session key from the premaster secret, the client random, and the server random. <br>
      7. The client is finished. <br>
      8. The server is finished. <br>
      9. Communicate can now proceed between the client and the server. <br>
      <br>

      !---- EASY TLS HANDSHAKE PICTURE ---!
      TLS 1.3 cuts down the handshake, there are less cipher suites, so the client can guess what the server will pick. This means that the client can send all of it's information in one big hello, and generate the premaster secret then. <br>
      When the server responds with its information, since it already has the premaster secret, it makes it's own master secret and also sends the finished message. <br>
      Then the client verifies the certificate, digital signature, generates its master secret, and sends its finished message. And that's it!
      <br>
    </p>

    <h3>The Heartbeat Request</h3>
    <p>
      <video id="dynamicVideo" controls>
        <source src="videos/Heartbeat.mp4" type="video/mp4">
      </video> <br>
      Now that the client and the server are connected and communicating, there may occasionally be lulls in the communication (user may not be downloading or doing anything).
      To make sure that the other is still there, they will send a "heartbeat request" to the other. This heartbeat request includes some encrypted data, and data about it's own length. 
      And the other computer will store that message in a memory buffer (a physical place in memory where it stores data), and then reply back with the exact same encrypted data.
      This ensures that the two computers are still connected, and one didn't drop. 
      However the one big flaw, is that the OpenSSL implementation does not check whether the length of the message one computer says it is, is actually correct. They could lie and the other
      computer would never know.

    </p>

    <h2 id="How_Heartbleed_Works">How Does Heartbleed Work?</h2>
    <p>
      <video id="dynamicVideo2" controls>
        <source src="videos/Heartbleed.mp4" type="video/mp4">
      </video> <br>
      So how does heartbleed work? Let's go through an example of exploiting the heartbeat request.
      The client will send the server "Hey I'm still here! (40KB)" and the server will see, oh I have a message of 40KB to store in my memory buffer, let me make 40KB of space to store it.
      The thing is though, the server doesn't check to see if the message actually is 40KB. So this could mean the client sends a message much larger than it actually is. <br>
      So when the server goes to allocate storage in its memory, it only allocates 2KB, since that's the actual length of the "Hey I'm still here!" message.
      But now the server needs to respond to the client with the exact message, which was supposedly 40KB. So the server goes to its memory buffer, takes out 40KB of message starting at where the client's message started,
      and then sends that back. So now the client receives its 2KB message, plus 38KB of the message stored after it in memory. <br>
      Now an attacker can't know where their message will be stored in memory, and what comes after it, but if they get lucky, or just keep trying enough, it could return usernames, passwords, private keys, social security numbers,
      or all kinds of sensitive information.
      
      
      
      Da bad bad request says it has big payload. It does not. Boom buffer overflow on the read and that schnitzle is exposed.
      It don't matter what's in memory. Keys? Secrets? Pornhub history? LEAKED!!
    </p>

    <h2 id="How_to_Fix_Heartbleed">How to Fix Heartbleed?</h2>
    <p>Luckily, it's pretty easy to fix Heartbleed. All you need to do is to update OpenSSL to the latest version.
      You can do this with the command in the terminal.
      <pre><code>sudo apt install --only-upgrade openssl</code></pre>
      So it's pretty easy to fix Heartbleed, so it's probably gone today, right?
    </p>

    <h2 id="Heartbleed_Today">Heartbleed's Impact Today</h2>
    <p>Heartbleed was discovered in 2014, basically a decade ago, so is it still even relevant?
      According to the SANS institute in a <a href="https://isc.sans.edu/diary/26798">2020 paper,</a>
      they used Shodan, basically a search engine for servers, showed that over 204,000 servers were still vulnerable to heartbleed.
      A Japanese tech company, NTT, states in their <a href="https://services.global.ntt/en-us/insights/2020-global-threat-intelligence-report#form">2020 report</a> report that 
      OpenSSL is targeted by attackers because of heartbleed.</p>

      <h4>Why is it such a problem?</h4>
      <p>
      Within software, there's a lot of 3rd party libraries, applications, and components that often go into them, and while this software's
      server is fully updated and secure from Heartbleed, those 3rd party components may not be. And there's a chance an attacker could
      exploit Heartbleed in this 3rd party component, which gives them a door into the otherwise Heartbleed-secured software.

      Another problem, is that some devices were not meant to be updated, such as some home IoT devices or medical devices. Especially in the case of medical devices,
      they may get placed in areas that are hard to access, and they don't connect to the Internet to be able to download the new version. 
      Or in some cases, they just weren't built with needing upgrades in the first place.
      These devices are kind of stuck with the version they ship with.
    </p>

    <h2 id="Detect_Heartbleed">How to Detect Heartbleed</h2>
    <p>There are many ways to detect whether a system is vulnerable to Heartbleed. The methods we will go over include: manually checking, commandline tools, online tools, and vulnerability scanners.
    </p>
    <h3>Checking manually</h3>
    <p>Versions 1.0.1, 1.0.1a, 1.0.1b, 1.0.1c, 1.0.1d, 1.0.1e, 1.0.1f are vulnerable to the heartbleed bug. This can be can manually test this by typing </p>
      <pre><code>openssl version</code></pre> 
      <p>into a terminal, and if the results are not one of the mentioned versions, then the system is not vulnerable to heartbleed.
       </p>
    <h3>Commandline Tools</h3>
    <h4>OpenSSL tools</h4>
    You can use OpenSSL itself to check for heartbleed. Open the terminal and paste this command into it. It will say "safe" if your server is not vulnerable to heartbleed.
    <p><pre><code>echo "QUIT"|openssl s_client -connect example.com:443 2>&1|grep 'server extension "heartbeat" (id=15)' || echo safe</code></pre></p>
    
    <h4>nmap Scans</h4>
    <p>Another option is to use nmap. Nmap is a port scanning tool, which means it will scan an IP or domain for what ports and connections it has open,
      but it can detect for some vulnerabilities and other information as well.
    </p>
    <pre><code>nmap --script ssl-heartbleed -p 443 example.com</code></pre>
    <p>or</p>
    <pre><code>nmap --script ssl-heartbleed -p 443 198.168.1.1</code></pre>
    <p>Depending on whether you want to use an domain or an IP.</p>
    
    <h3>Online tools</h3>
    <h4>Qualys</h4>
    <p>Qualys makes a server scanner that looks at a lot of different things related to TLS. It will search for common vulnerabilities (heartbleed included!), as well as other common SSL attacks like POODLE. 
      It will also check some other basics such as certificates and ciphers they're using.
      If your server is on the public Internet, you can copy the link and paste it in <a href="https://www.ssllabs.com/ssltest/">Qualys.</a></p>

    <h4>DomSignal</h4>
    <p>DomSignal is another server TLS scanner that will check for the health of your TLS implementation.
      Just like Qualys, it will search for common misconfigurations and vulnerabilities, including heartbleed.
      Once again, your server has to be on the public Internet, but you can copy the link and paste it here <a href="https://domsignal.com/tls-scanner">DomSignal.</a>
    </p>

    <h4>Vulnerability Scanners</h4>
    <p>Vulnerability scanners are pretty similar to the online tools mentioned above (they're both vulnerability scanners overall),
      but they'll have some slightly different implementation differences and capabilities. Some common scanners are Nessus and OpenVAS,
      and they will both scan your system for common misconfigurations and vulnerabilities. One of the advantages that these scanners have
      over the online tools like Qualys and DomSignal is customizability. Both Nessus and OpenVAS allows you to install additional plugins
      and settings for your vulnerability scan.
    </p>
    <h2 id="Heartbleed_Demo">Heartbleed in Action</h2>
    

    <h2 id="Quiz">Heartbleed Knowledge Quiz</h2>
    <p>Now that you've learned about Heartbleed, you can take the quiz! Score a 90% or higher to pass.</p>
    <a href="quiz.html">Take the quiz</a>

  </main>

  <!-- <div class="footer">
    <h1>Footer</h1>
  </div> -->

  <script src="javascript/script.js"></script>
</body>

</html>
